# ЛР №2
![Снимок экрана 2024-05-13 144221](https://github.com/iis-32170x/RPIIS/assets/144945398/57029c4c-fd90-4f3f-ba12-325b0cf94c26)

# Условие ЛР2 (7 - вариант)
В рамках ЛР 2 необходимо реализовать программу, формирующую без повторений всевозможные ориентированные
множества из элементов исходного неориентированного множества, количество
элементов в сформированных множествах должно быть равно исходному натуральному n.

# Основные понятия

Мно́жество — одно из ключевых понятий математики, представляющее собой набор, совоку́пность каких-либо (вообще говоря любых) объектов — элеме́нтов этого множества. Два множества равны тогда и только тогда, когда содержат в точности одинаковые элементы.

Неориентированное множество - множество в котором ребра не имеют направления.

Ориентированное множество - множество в котором ребра имеют направления.



# Описание алгоритма

1. Создание вектора `mnosh`, который представляет собой входное множество чисел.

2. Проверка наличия дубликатов во входном множестве. Если дубликаты найдены, выводится сообщение об ошибке.

3. Создание вектора `current` размером, равным размеру входного множества `mnosh`. Этот вектор будет служить временным хранилищем для текущей комбинации.

4. Создание вектора `graphs`, который будет содержать все сгенерированные комбинации.

5. Вызов функции `generateGraphs`, которая рекурсивно генерирует все возможные комбинации множества чисел. Эта функция принимает векторы `graphs`, `current` и `mnosh`, а также индекс текущего элемента (начиная с 0).

6. В функции `generateGraphs` происходит итерация по всем элементам множества `mnosh`. Для каждого элемента проверяется его допустимость в текущей комбинации. Если элемент еще не был использован ранее, он добавляется в текущую комбинацию и вызывается рекурсивный вызов функции `generateGraphs` для следующего индекса.

7. Если индекс превышает размер множества `mnosh`, значит, была сформирована полная комбинация. Эта комбинация добавляется в вектор `graphs`.

8. После завершения рекурсии, функция `Graphs` выводит все сгенерированные комбинации на экран.

9. В функции `main` происходит ввод размера множества и его элементов, а затем вызываются функции `Dupl`, `generateGraphs` и `Graphs` для получения и вывода комбинаций.


## Функции

### Комбинации  

Описание: Рекурсивно генерирует все возможные комбинации множества чисел без повторений.

``` void generateGraphs(vector<vector<int>>& graphs, vector<int>& current, const vector<int>& mnosh, int index = 0) {
    if (index >= mnosh.size()) {
        graphs.push_back(current);
        return;
    }
    
    
    for (int i = 0; i < mnosh.size(); ++i) {
        bool isValid = true;
        for (int j = 0; j < index; ++j) {
            if (current[j] == mnosh[i]) {
                isValid = false;
                break;
            }
        }
        if (isValid) {
            current[index] = mnosh[i]; 
            generateGraphs(graphs, current, mnosh, index + 1);
        }
    }
}
```

### Вывод комбинаций
Описание: Выводит все сгенерированные комбинации на экран.

```void Graphs(const vector<vector<int>>& graphs) {
    for (const auto& graph : graphs) {
        cout << "{";
        for (int i = 0; i < graph.size(); ++i) {
            cout << graph[i];
            if (i != graph.size() - 1) {
                cout << " , ";

            }
        }
        cout << "}" << '\n';
    }
}
```

## Пример запуска

При запуске программы, первым делом программа просит нас ввести размер множества.

![Снимок экрана 2024-05-13 145412](https://github.com/iis-32170x/RPIIS/assets/144945398/d9cec140-7c72-4e78-83d2-67fe95ef52c8)

Затем программа просит ввести элементы этого множества.

![Снимок экрана 2024-05-13 145421](https://github.com/iis-32170x/RPIIS/assets/144945398/2b37dd8b-42ee-41bc-958e-e5759d8b221e)

После  программа выводит все возможные ориентированные множества без повторений.

![Снимок экрана 2024-05-13 145429](https://github.com/iis-32170x/RPIIS/assets/144945398/1af7d9ba-6cde-409b-a31f-e779e123a787)

## Вывод
Реализовал программу формирующую без повторений всевозможные ориентированные
множества

