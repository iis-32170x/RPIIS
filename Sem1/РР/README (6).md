# *Расчётная работа*
## Введение
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.4 Найти компоненты связности в неориентированном графе

Реализовать на C++ код, который находитъ компоненты связности

Граф(неориентированный) представляется в виде матрицы инцедентности.
### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Нериентированный граф` — Граф, ни одному ребру которого не присвоено направление.

`Матрица инцедентности` - одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина).

`Компонента связности` - набор вершин графа, между любой парой которых существует путь.
## Алгоритм решения
Вводим граф в виде матрицы инцедентности. Производим поиск в глубину от первой вершины и следующих непроверенных. Выводим в консоль компоненты связности
## Реализация на С++
Код, выполняющий приведённый алгоритм:
```C++
#include <iostream>

using namespace std;

const int n = 13;
const int m = 14;

int Mas[n][m] = { };

bool used[n];

int a = 0, b = 0, d = 0, i = 0, k = 0;

void dfs(int t) 
{
	used[t] = true;
	for (int a = 0; a < m; a++)
	{
		if (Mas[t][a] == 1)
		{
			for (int b = 0; b < n; b++)
			{
				if (Mas[b][a] == 1 && used[b] == 0)
				{
					dfs(b);
					cout << b + 1 << " ";
				}
			}
		}
	}
}
int main()
{
	for (int i = 0; i < n; i++)
	{
		used[i] = false;
		for (int k = 0; k < m; k++)
			cout << " " << Mas[i][k];
		cout << endl;
	}
	while (d < n)
	{
		if (used[d] == 0)
		{
			cout << d + 1 << " ";
			dfs(d);
			cout << endl;
		}
		d++;
	}
	return 0;
}

```
## Разбор кода
- `#include <iostream>` - библиотека для ввода \ вывода
- `using namespace std` - подключение пространства имен `std`
- `const int n` - задание переменной, ответственной за кол-во вершин графа
- `const int m` - задание переменной, ответственной за кол-во рёбер графа
- `int Mas[n][m]` - задание матрицы инцедентности
- `bool used[n]` - создание переменной состояния вершины
- `int a = 0, b = 0, d = 0, i = 0, k = 0` - инициализация переменных для работы циклов
- `void dfs(int t) ` -  создание фунции поиска в глубину с переменной t, ответсвенную за номер проверенной вершины
- `used[t] = true` - изменение состояния вершины на проверенную
- `for (int a = 0; a < m; a++)` - цикл проверки вершин
- `if (Mas[t][a] == 1)` - проверка вершины на связь с ребром
- `for (int b = 0; b < n; b++)` - если вершина связана с ребром, то цикл поиска связанной вершины
- `if (Mas[b][a] == 1 && used[b] == 0)` - проверка связи с каждой вершиной
- `dfs(b)` - если связано, то запускать поиск с новой вершины
- `cout << b + 1 << " "` - вывод данной вершины
- `int main()` - основная фунция
- `for (int i = 0; i < n; i++)` - цикл вывода условия в консоль
- `while (d < n)` - цикл поиска в глубину с разных вершин
- `if (used[d] == 0)` - проверка состояния точки
- `cout << d + 1 << " "` - если проверка прошла, то вывести данную точку
- `dfs(d);` - начать поиск с даннйо точки
- `cout << endl;` - после проверки компоненты связности перевести курсор на следующий абзац
- `d++` - увеличение номера проверяемой точки 

## Тестирование
Все тесты и наглядные изображения графов, участвующих в них, можно посмотреть [здесь](https://github.com/iis-32170x/RPIIS/tree/%D0%9A%D0%BE%D1%80%D0%BE%D0%BB%D1%8C_%D0%93/%D0%A0%D0%A0/%D0%A2%D0%B5%D1%81%D1%82%D1%8B).
## Вывод
В результате выполнения расчётной работы приобрёл следующие навыки:

- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
