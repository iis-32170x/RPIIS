# Лабораторная работа №1 2-го семестра по предмету 'Представление и обработка информации в интеллектуальных системах'

- `Цель` - 28. Дерево Хаффмана. Зашифровать текст с помощью дерева.
- `Вариант` - $\textcolor{grey}{\textit{28}}$

## Список ключевых понятий (определения)

- `Дерево Хаффмана` -  это способ кодирования данных, который минимизирует среднюю длину кодов. Символы, которые чаще всего встречаются, получают более короткие коды, а реже встречающиеся — более длинные. Это бинарное дерево, где каждый узел представляет символ и его частоту.

- `Декодирование` - обратный процесс, где закодированные данные с помощью дерева Хаффмана декодируются обратно в исходный текст.
- `Частота символов`. Для построения дерева Хаффмана необходимо знать частоту встречаемости каждого символа в исходном тексте. Эти частоты определяют, как будет строиться дерево.

## Алгоритм

**Шаг 1.** *Помещаем все листья с ненулевым числом появлений в очередь с приоритетами (упорядочиваем все листья в порядке убывания числа появления)*

**Шаг 2.** *Пока в очереди больше одного узла, выполняем следующие действия:*

**Шаг 2a.** *Удаляем из очереди два узла с наивысшим приоритетом (самыми низкими числами появлений)*

**Шаг 2b.** *Создаём новый узел, для которого выбранные на шаге 2a узлы являются наследниками. При этом число появлений нового узла (его вес) полагается равным сумме появлений выбранных на шаге 2a узлов*

**Шаг 2c.** *Добавляем узел, созданный на шаге 2b, в очередь с приоритетами.*

## Принцип работы программы

Программа реализует алгоритм Хаффмана, который сжимает строку, используя частоту появления символов: сначала она подсчитывает, как часто встречается каждый символ, затем строит бинарное дерево (дерево Хаффмана), где символы с более высокой частотой располагаются ближе к корню. Для каждого символа генерируется уникальный двоичный код, причём более частые символы получают более короткие коды. В итоге программа выводит таблицу с кодами символов и сжатую строку, заменяя символы их кодами.

## Функции

### huffman_encode(s)

Принимает строку s и строит дерево Хаффмана для создания оптимальных кодов символов, которые можно использовать для сжатия строки. Она работает следующим образом:

1.	**Подсчет частот символов**: Сначала с помощью Counter(s) функция подсчитывает, как часто каждый символ встречается в строке. Для каждого символа создается лист (Leaf) дерева Хаффмана, и вместе с его частотой лист добавляется в кучу (приоритетную очередь) h.
2.	**Построение кучи**: Список, содержащий кортежи вида (частота, индекс, лист), преобразуется в минимальную кучу с помощью heapq.heapify(h), что позволяет быстро извлекать элементы с наименьшей частотой.
3.	**Создание дерева Хаффмана**: Пока в куче больше одного элемента, извлекаются два символа (или узла) с наименьшей частотой, и они объединяются в новый узел (Node), представляющий сумму их частот. Этот новый узел добавляется обратно в кучу. Процесс повторяется до тех пор, пока не останется один элемент — корень дерева Хаффмана.
4.	**Генерация кодов**: После создания дерева вызывается метод walk для обхода дерева от корня. Во время обхода каждому символу присваивается двоичный код: “0” при движении влево и “1” при движении вправо. Результат сохраняется в словаре code.
5.	**Возврат результата**: Функция возвращает словарь, где каждому символу строки соответствует его двоичный код.


### Код реализации:

```py

from collections import Counter, namedtuple
import heapq

class Node(namedtuple("Node", ["left", "right"])):
    def walk(self, code, acc):
        self.left.walk(code, acc + "0")
        self.right.walk(code, acc + "1")

class Leaf(namedtuple("Leaf", ["char"])):
    def walk(self, code, acc):
        code[self.char] = acc or "0"

def huffman_encode(s):
    h = []
    for ch, freq in Counter(s).items():
        h.append((freq, len(h), Leaf(ch)))
    heapq.heapify(h)
    count = len(h)
    while len(h) > 1:
        freq1, _count1, left = heapq.heappop(h)
        freq2, _count2, right = heapq.heappop(h)
        heapq.heappush(h, (freq1 + freq2, count, Node(left, right)))
        count += 1
    code = {}
    if h:
        [(_freq, _count, root)] = h
        root.walk(code, "")
    return code
 
def main():
    s = input()
    code = huffman_encode(s)
    encoded = "".join(code[ch] for ch in s)
    print(len(code), len(encoded))
    for ch in sorted(code):
        print("{}: {}".format(ch, code[ch]))
    print(encoded)

if __name__ == "__main__":
    main()
```

## Вывод

Реализовал программу, которая принимает строку и строит дерево Хаффмана
