# Лабораторная работа №2 по предмету 'Представление и обработка информации в интеллектуальных системах'

- `Цель` - 10. Реализовать программу, формирующую множество равное объединению произвольного
количества исходных множеств (с учётом кратных вхождений элементов).
- `Вариант` - $\textcolor{grey}{\textit{10}}$

## Список ключевых понятий (определения)

- `Объединение двух множеств` -  теоретико-множественная операция, результатом которой является множество, в которое входят все элементы первого и второго множества.

- `Элементом множества` может являться число, кортеж, отдельное множество, сочетание буквы и числа.

## Алгоритм

## Сегодня я узнал: Объединение множеств с вложенными множествами

Эта программа принимает на вход три множества, представленные в виде строк, где элементы разделены запятыми, а вложенные множества заключены в фигурные скобки. Например: `{1, 2, {3, 4}, 5}`.

## Функции

### parse_set_from_string(s)

Эта функция выполняет анализ строки, которая представляет множество, и преобразует её в объект CustomSet, поддерживающий вложенные множества. Она корректно обрабатывает как плоские множества, так и вложенные, используя стек для отслеживания текущей глубины вложенности.

**Алгоритм работы:**

1) Инициализируется стек для хранения промежуточных множеств.
2) По каждому символу строки:
3) Если найден открывающий символ множества {, создается новое множество, которое добавляется в стек.
4) Если найден закрывающий символ множества }, текущее множество завершается, и его добавляют в родительское множество (из стека).
5) Если найдено число, оно добавляется в текущее множество.
6) В конце, если множество вложено, оно возвращается в родительское множество.

### union_with_multiplicity(*sets)

Эта функция выполняет объединение нескольких множеств с учетом кратности элементов и поддерживает вложенные множества. Она проходит через все элементы входных множеств, сохраняя их кратность с помощью структуры Counter.

**Алгоритм работы:**

1) Используется структура данных Counter для учета частоты появления каждого элемента в множествах.
2) Сначала все множества проходят через функцию flatten, которая преобразует вложенные множества в плоскую структуру для корректного подсчета кратности.
3) Затем элементы объединяются в итоговое множество, и каждая копия элемента добавляется в результирующее множество согласно его кратности.
4) Функция поддерживает элементы как простые значения, так и вложенные множества.

### CustomSet

Это класс, который наследует функциональность стандартного множества set, но расширяет её для поддержки вложенных множеств.

Особенности:

1) Метод **add(element)**: Обрабатывает как обычные элементы, так и вложенные множества. Вложенные множества преобразуются в frozenset, что позволяет им быть хэшируемыми и добавляться в CustomSet.
2) Метод **remove(element)**: Удаляет элемент или вложенное множество из множества. В случае вложенных множеств используется frozenset.
3) Метод **flatten()**: Этот метод рекурсивно проходит по всем элементам множества и возвращает их в виде списка, включая элементы вложенных множеств.
4) Метод **__repr__()**: Переопределяет способ отображения множества, так что вложенные множества отображаются корректно в виде строк, обрамленных фигурными скобками {}.

### read_sets_from_file(file_path)

Эта функция читает строки, содержащие множества, из файла и преобразует их в объекты CustomSet.

**Алгоритм работы:**

1) Открывает файл и по каждой строке:
2) Очищает строку от лишних символов (пробелов и символов перевода строки).
3) Преобразует строку в CustomSet с помощью функции parse_set_from_string.
4) Добавляет результат в список для дальнейшей обработки.

### Код реализации для разности

```py


from collections import Counter

class CustomSet(set):
    def add(self, element):
        """Переопределенный метод add для поддержки вложенных множеств."""
        if isinstance(element, CustomSet):
            # Преобразуем вложенное CustomSet в frozenset для хэшируемости
            super().add(frozenset(element))
        else:
            super().add(element)
    
    def remove(self, element):
        """Переопределенный метод remove для поддержки вложенных множеств."""
        if isinstance(element, CustomSet):
            # Преобразуем вложенное CustomSet в frozenset для хэшируемости
            super().remove(frozenset(element))
        else:
            super().remove(element)

    def __contains__(self, element):
        """Переопределенный метод __contains__ для проверки наличия элемента."""
        if isinstance(element, CustomSet):
            # Проверяем наличие frozenset (вложенного множества)
            return frozenset(element) in super().__contains__(element)
        else:
            return super().__contains__(element)

    def flatten(self):
        """Метод для получения всех элементов в виде списка, включая элементы из вложенных множеств."""
        flat_list = []
        for item in self:
            if isinstance(item, frozenset):
                # Рекурсивное распаковывание вложенного множества
                flat_list.extend(CustomSet(item).flatten())
            else:
                flat_list.append(item)
        return flat_list

    def __repr__(self):
        """Переопределяем __repr__ для корректного отображения вложенных множеств."""
        def set_repr(s):
            elements = [set_repr(e) if isinstance(e, frozenset) else repr(e) for e in s]
            return '{' + ', '.join(elements) + '}'
        return set_repr(self)

def parse_set_from_string(s):
    """Парсинг строки в CustomSet с учетом вложенных структур."""
    stack = []  # Стек для отслеживания вложенных множеств
    current_set = CustomSet()  # Текущее множество для добавления элементов
    
    i = 0
    while i < len(s):
        if s[i] == '{':
            # Начало нового вложенного множества
            stack.append(current_set)
            current_set = CustomSet()
            i += 1
        elif s[i] == '}':
            # Конец текущего множества
            if stack:
                parent_set = stack.pop()
                parent_set.add(current_set)
                current_set = parent_set
            i += 1
        elif s[i].isdigit() or (s[i] == '-' and s[i+1].isdigit()):
            # Обработка чисел
            j = i
            while j < len(s) and (s[j].isdigit() or s[j] == '-'):
                j += 1
            num = int(s[i:j])
            current_set.add(num)
            i = j
        else:
            i += 1  # Пропуск символов (например, пробелов)

    return current_set

def union_with_multiplicity(*sets):
    """Объединение множеств с учетом кратности элементов и вложенных структур."""
    combined_set = CustomSet()  # Итоговое множество для объединения всех входных множеств
    combined_counter = Counter()  # Счетчик для учета кратности элементов

    for s in sets:
        flattened_elements = s.flatten()
        combined_counter.update(flattened_elements)
    
    for element, count in combined_counter.items():
        for _ in range(count):
            combined_set.add(element)
    
    return combined_set

def read_sets_from_file(file_path):
    """Чтение множеств из файла и преобразование строк в объекты CustomSet."""
    sets = []
    with open(file_path, 'r') as file:
        for line in file:
            cleaned_line = line.strip()  # Убираем лишние пробелы и символы перевода строки
            # Преобразуем строку в CustomSet
            set_from_line = parse_set_from_string(cleaned_line)
            sets.append(set_from_line)
    return sets

# Пример использования
sets = read_sets_from_file('sets.txt')

result = union_with_multiplicity(*sets)

print(result)
```

## Вывод

Реализовал программу, которая выполняет объединение множеств с учетом их кратности.
