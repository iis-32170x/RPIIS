# Лабораторная работа по дисциплине ПиОИвИС №1, второй семестр
## Цель работы
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.
## Индивидуальное задание №4
Бинарное дерево поиска. Поиск узла в дереве. Вставка узла в дерево.
Удаление узла из дерева. Обходы дерева. Построение дерева из
массива.
## Ключевые понятия
***Дерево*** — структура данных, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы.

***Дочерний узел бинарного дерева*** —  это узел, который находится непосредственно ниже другого узла в иерархии дерева. В бинарном дереве каждый узел может иметь не более двух дочерних узлов: левый и правый.

***Корневой узел*** — самый верхний узел дерева.

***Лист*** (листовой или терминальный узел) — узел, не имеющий дочерних элементов.

***Внутренний узел*** — любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом.

***Бинарное дерево поиска***—дерево, для которого выполняются следующие дополнительные условия: оба поддерева — левое и правое — являются двоичными деревьями поиска; у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X.

## Пример бинарного дерева поиска

![image](https://neerc.ifmo.ru/wiki/images/e/e6/Bst_search.png)

## Алгоритм 

**Основные операции:**
- *createNode*- функция создания узла
- *insertNode* - функция вставки нового узла
- *search* - функция поиска узла
- *buildTree* - функция для построения дерева из массива
- *printTree* - функция отображения дерева
- *findMinNode* - функция для поиска наименьшего элемента в бинарном дереве
- *deleteNode* - функция для удаления элемента из бинарного дерева поиска
- *preOrderTraversal* - функция обхода дерева в прямом порядке (pre-order)
- *inOrderTraversal* - функция обхода дерева в симметричном порядке (in-order)
- *postOrderTraversal* - функция обхода дерева в обратном порядке (post-order)
- *clearTree* - функция очистки памяти

### Объявление структуры, описывающей один узел бинарного дерева поиска
```cpp
struct Node
{
    int key;
    Node* left;
    Node* right;
};
```

### Функция создания узла бинарного дерева поиска
Создает новый узел бинарного дерева с ключом value и возвращает указатель на него. Левое и правое поддеревья устанавливаются в nullptr.
```cpp
Node* createNode(int value)
{
    Node* newNode = new Node();
    newNode->key = value;
    newNode->left = newNode->right = nullptr;
    return newNode;
}
```

### Функция отображения бинарного дерева поиска
Выводит значения узлов бинарного дерева поиска в порядке убывания (правое поддерево, корень, левое поддерево). Использует рекурсию для обхода дерева и вывода значений узлов, добавляя отступы для визуального представления уровней дерева.
```cpp
void printTree(Node* root)
{
    if (root == nullptr) 
    {
        return;
    }

    tabs += 5;

    printTree(root->right);

    for (int i = 0; i < tabs; i++) 
    {
        cout << " ";
    }

    cout << root->key << endl;

    printTree(root->left);

    tabs -= 5;
    return;
}
```
### Функция для построения бинарного дерева поиска из массива
Строит бинарное дерево поиска из отсортированного массива arr, используя алгоритм деления пополам. Рекурсивно создает узлы дерева с ключами, соответствующими среднему элементу каждого подмассива, и связывает их с левыми и правыми поддеревьями, построенными для левой и правой половин массива соответственно. Возвращает указатель на корень построенного дерева.
```cpp
Node* buildTree(int arr[], int start, int end)
{
    // Проверка наличия элементов в массиве
    if (start > end)
        return NULL;

    // Вычисление индекса корневого элемента
    int mid = (start + end) / 2;

    // Создание узла дерева из среднего элемента массива
    Node* root = createNode(arr[mid]);

    // Рекурсивное построение левого и правого поддеревьев
    root->left = buildTree(arr, start, mid - 1);
    root->right = buildTree(arr, mid + 1, end);

    return root;
}
```
***Важно, чтобы построение дерева шло из массива после сортировки его по возрастанию!!!***

### Функция для вставки нового узла в бинарном дереве поиска
Вставляет новый узел с ключом value в бинарное дерево поиска, представленное указателем root. Если дерево пустое, создается новый узел и делается корнем. Если ключ меньше значения корневого узла, функция рекурсивно вызывается для левого поддерева. Если ключ больше значения корневого узла, функция вызывается для правого поддерева. Возвращает указатель на корень дерева.
```cpp
Node* insertNode(Node* root, int value)
{
    // Если дерево пустое, создаем новый узел и делаем его корнем
    if (root == nullptr)
    {
        root = createNode(value);
        return root;
    }

    // Рекурсивно вставляем элемент в правильное поддерево
    if (value < root->key)
    {
        root->left = insertNode(root->left, value);
    }
    else if (value > root->key)
    {
        root->right = insertNode(root->right, value);
    }

    return root;
}
```

### Функция для поиска узла в бинарном дереве поиска
Выполняет поиск узла с ключом key в бинарном дереве поиска, представленном указателем root. Если дерево пустое или ключ корня совпадает с искомым ключом, выводит соответствующее сообщение. В противном случае, функция рекурсивно вызывается для левого или правого поддерева в зависимости от значения ключа корня. Возвращает true, если узел найден, и false в противном случае.
```cpp
bool search(Node* root, int key)
{
    // Если дерево пустое или ключ корня равен искомому ключу
    if (root == nullptr || root->key == key)
    {
        if (root != nullptr)
        {
            cout << "Элемент найден." << endl;
        }
        else
        {
            cout << "Элемент не найден." << endl;
        }
        return true;
    }

    // Если искомый ключ меньше ключа корня, рекурсивно ищем в левом поддереве
    if (key < root->key)
    {
        return search(root->left, key);
    }

    // Если искомый ключ больше ключа корня, рекурсивно ищем в правом поддереве
    return search(root->right, key);
}
```

### Функция для поиска наименьшего элемента в бинарном дереве поиска
Находит и возвращает указатель на узел с наименьшим ключом в бинарном дереве поиска, представленном указателем root. Если дерево пустое, возвращает nullptr. Функция последовательно спускается влево от корня, пока не достигнет узла с наименьшим ключом.
```cpp
Node* findMinNode(Node* root) 
{
    if (root == nullptr) 
    {
        return nullptr;
    }
    while (root->left != nullptr) 
    {
        root = root->left;
    }
    return root;
}
```

### Функция для удаления элемента из бинарного дерева поиска
Функция deleteNode удаляет узел с ключом key из бинарного дерева поиска. Если дерево пустое, возвращает nullptr. В противном случае, функция вызывается рекурсивно для левого или правого поддерева в зависимости от значения ключа корня. Если ключ совпадает со значением корневого узла, узел удаляется.
Если узел имеет одного или отсутствует детей, он просто удаляется. Если узел имеет двух детей, он заменяется на наименьший узел из правого поддерева (или наибольший узел из левого поддерева), а затем этот узел удаляется из соответствующего поддерева.
Возвращается указатель на измененное дерево.
```cpp
Node* deleteNode(Node* root, int key)
{
    if (root == nullptr)
        return root;

    // Если ключ меньше значения корневого узла, рекурсивно ищем и удаляем в левом поддереве
    if (key < root->key)
        root->left = deleteNode(root->left, key);
    // Если ключ больше значения корневого узла, рекурсивно ищем и удаляем в правом поддереве
    else if (key > root->key)
        root->right = deleteNode(root->right, key);
    // Если ключ совпадает со значением корневого узла, удаляем корневой узел
    else
    {
        // Узлы с одним или без детей удаляются просто путем освобождения памяти
        if (root->left == nullptr)
        {
            Node* temp = root->right;
            delete root;
            return temp;
        }
        else if (root->right == nullptr)
        {
            Node* temp = root->left;
            delete root;
            return temp;
        }
        // Узлы с двумя детьми заменяются на узел с наименьшим ключом из правого поддерева
        Node* temp = findMinNode(root->right);
        root->key = temp->key;
        root->right = deleteNode(root->right, temp->key);
    }
    return root;
}
```

### Функция для обхода дерева в прямом порядке (pre-order)
```cpp
Рекурсивный обход дерева в прямом порядке (pre-order) осуществляется следующим образом:
•	Если указатель node равен nullptr, функция завершает работу.
•	Иначе, выводится значение ключа текущего узла node->key, а затем рекурсивно вызывается preOrderTraversal для левого поддерева и правого поддерева.

void preOrderTraversal(Node* node)
{
    if (node == nullptr)
        return;

    cout << node->key << " "; // Посещаем текущий узел
    preOrderTraversal(node->left); // Рекурсивно обходим левое поддерево
    preOrderTraversal(node->right); // Рекурсивно обходим правое поддерево
}
```

### Функция для функция обхода дерева в симметричном порядке (in-order)
Рекурсивный обход дерева в симметричном порядке (in-order) осуществляется следующим образом:
•	Если указатель node равен nullptr, функция завершает работу.
•	Иначе, рекурсивно вызывается inOrderTraversal для левого поддерева, затем выводится значение ключа текущего узла node->key, а затем рекурсивно вызывается inOrderTraversal для правого поддерева.

```cpp
void inOrderTraversal(Node* node)
{
    if (node == nullptr)
        return;

    inOrderTraversal(node->left); // Рекурсивно обходим левое поддерево
    cout << node->key << " "; // Посещаем текущий узел
    inOrderTraversal(node->right); // Рекурсивно обходим правое поддерево
}
```

### Функция для функция обхода дерева в обратном порядке (post-order)
Рекурсивный обход дерева в обратном порядке (post-order) осуществляется следующим образом:
•	Если указатель node равен nullptr, функция завершает работу.
•	Иначе, рекурсивно вызывается postOrderTraversal для левого поддерева, затем рекурсивно вызывается postOrderTraversal для правого поддерева, а после этого выводится значение ключа текущего узла node->key.

```cpp
void postOrderTraversal(Node* node)
{
    if (node == nullptr)
        return;

    postOrderTraversal(node->left); // Рекурсивно обходим левое поддерево
    postOrderTraversal(node->right); // Рекурсивно обходим правое поддерево
    cout << node->key << " "; // Посещаем текущий узел
}

```

### Функция для функция очистки памяти
Рекурсивная функция для очистки памяти дерева осуществляется следующим образом:
•	Если указатель root равен nullptr, функция завершает работу.
•	Иначе, рекурсивно вызывается clearTree для левого поддерева, затем рекурсивно вызывается clearTree для правого поддерева, и после этого удаляется корневой узел root.
```cpp
void clearTree(Node* root)
{
    if (root == nullptr) 
{
        return;
    }

    clearTree(root->left);
    clearTree(root->right);

    delete root;
}
```

## Пример выполнения:


### Введём произвольный массив из 10 элементов: {9 7 6 4 3 1 2 5 10 0}


### Сортируем массив по возрастанию: {0 1 2 3 4 5 6 7 9 10}


### Получаем бинарное дерево поиска.
![Image alt](https://github.com/iluxa313/iluxa313/blob/main/скрин1.png)


### Выбираем операцию вставки элемента в дерево и получаем преобразованное дерево с добавленным узлом.
![Image alt](https://github.com/iluxa313/iluxa313/blob/main/скрин2.png)


### Выбираем операцию поиска элемента, вводим искомый элемент и получаем результат по находке.
![Image alt](https://github.com/iluxa313/iluxa313/blob/main/скрин3.png)


### Выбираем операцию удаления элемента, вводим искомый элемент и получаем получаем преобразованное дерево без этого узла.
![Image alt](https://github.com/iluxa313/iluxa313/blob/main/скрин4.png)


### Выбираем операцию обхода деревьев и получаем результат.
![Image alt](https://github.com/iluxa313/iluxa313/blob/main/скрин5.png)


### Выбираем операцию выхода, выходим из программы, при этом очищая за собой память.

## <p align="center">Результаты тестирования:</p>
### Тестирование проводилось с помощью фреймворка Google test.

![Image alt](https://github.com/iluxa313/iluxa313/blob/main/Снимок%20экрана%202024-03-03%20140420.png)

## Источники:
- https://www.youtube.com/watch?v=g0neKAAd668

- https://habr.com/ru/articles/267855/

- https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0,_%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F
