# Лабораторная работа №1

## Задача:
Реализовать красно-черное дерево. Вставка. Удаление. Поиск. Поиск минимума,
максимума, ближайшего большего и ближайшего меньшего.
## Цель:
Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных.

## Список ключевых понятий:
* *Красно - черное дерево* — двоичное дерево поиска, в котором баланс осуществляется на основе "цвета" узла дерева, который принимает только два значения: "красный" и "чёрный". Это структура данных, используемая в программировании для организации упорядоченного набора элементов.
* *Чёрная высота* - число вершин х на пути из x в лист.
* Красно-чёрное дерево с N ключами имеет высоту *h=O(logN)*.

## Свойства:
1. Каждый узел промаркирован красным или чёрным цветом
2. Корень и конечные узлы (листья) дерева — чёрные
3. У красного узла родительский узел — чёрный
4. Все простые пути из любого узла x до листьев содержат одинаковое количество чёрных узлов
5. Чёрный узел может иметь чёрного родителя
******
**При невыполнение хоть одного свойства дерево перестает быть красно-черным!** 
****
## Принцип работы программы:

1. **Конструктор RBTree**:
    - Создает объект красно-черного дерева.
    - Инициализирует указатель на корень дерева и фиктивный узел `TNULL`.
    - Устанавливает начальное значение цвета `TNULL` в черный.

2. **Метод insert(int key)**:
    - Создает новый узел с указанным ключом `key` и цветом 1 (красный).
    - Проводит поиск места для вставки нового узла в дерево.
    - Если дерево пустое, новый узел становится корнем.
    - После вставки узла происходит его балансировка с помощью метода `fixInsert(NodePtr k)`, чтобы сохранить свойства красно-черного дерева.

3. **Метод deleteNode(int key)**:
    - Ищет узел с ключом `key` в дереве.
    - В зависимости от количества потомков удаляемого узла выбирается подходящий случай удаления (0, 1 или 2 потомка).
    - После удаления узла происходит его балансировка с помощью метода `fixDelete(NodePtr x)`, чтобы сохранить свойства красно-черного дерева.

4. **Метод prettyPrint()**:
    - Выводит дерево в удобном для чтения формате на экран.
    - Использует рекурсивную функцию `printHelper(NodePtr root, string indent, bool last)`, которая проходит по дереву и выводит узлы, указывая их ключи и цвета, а также их положение относительно других узлов (левый или правый).

5. **Метод searchTree(int k)**:
    - Начальная функция поиска узла в дереве по ключу `k`.
    - Вызывает приватный вспомогательный метод `searchTreeHelper(NodePtr node, int key)`, который выполняет рекурсивный поиск узла с ключом `key` в поддереве с корнем `node`.

6. **Метод minimum(NodePtr node)**:
    - Находит и возвращает узел с минимальным ключом в поддереве с корнем `node`.
    - Движется влево от корня, пока не достигнет самого левого узла дерева.

7. **Метод maximum(NodePtr node)**:
    - Находит и возвращает узел с максимальным ключом в поддереве с корнем `node`.
    - Движется вправо от корня, пока не достигнет самого правого узла дерева.

8. **Метод successor(NodePtr x)**:
    - Находит и возвращает преемника (следующий по порядку узел) для узла `x` в дереве.
    - Если у узла есть правое поддерево, то преемник - самый левый узел в этом поддереве.
    - Иначе, преемник - первый родительский узел, в котором `x` находится в левом поддереве.

9. **Метод predecessor(NodePtr x)**:
    - Находит и возвращает предшественника (предыдущий по порядку узел) для узла `x` в дереве.
    - Если у узла есть левое поддерево, то предшественник - самый правый узел в этом поддереве.
    - Иначе, предшественник - первый родительский узел, в котором `x` находится в правом поддереве.

10. **Метод leftRotate(NodePtr x)**:
    - Выполняет левый поворот от

носительно узла `x`.
- Меняет указатели между `x` и его правым потомком `y`.

11. **Метод rightRotate(NodePtr x)**:
    - Выполняет правый поворот относительно узла `x`.
    - Меняет указатели между `x` и его левым потомком `y`.

## Реализация
 Т.к у дерева есть определенный набор свойств, которые должны выполнятся в любом случае, в реализации нужно сделать несколько **главных** частей:
 * Вставка новой вершины и балансировка дерева после
 * удаление вершины и балансировка дерева после


### Вставка новой вершины и балансировка дерева после:
Чтобы вставить узел K в красно-черное дерево T, мы делаем следующее:
1. Мы вставляем K, используя обычную операцию вставки BST.
2. Раскрасим К красным.
3. Проверяем, не нарушила ли вставка свойства красно-черного дерева. Если это произошло, мы это исправим.

Есть несколько случаев, которые нам необходимо рассмотреть. Предположим, P — родительский узел, U — дочерний узел, S — родственный узел, а G — родительский узел K.

***Случай 1: T пуст.***

Если T пусто, мы делаем K корнем дерева и окрашиваем его в черный цвет.

***Случай 2: P — черный.***

Если родительский узел P узла K черный, он не может нарушать ни одно из свойств. Поэтому в данном случае нам ничего делать не нужно.

***Случай 3: P красный.***

Если родительский узел P красный, это нарушает свойство 4. P и K теперь оба красные. Прародительский узел G должен быть черным узлом, поскольку дерево перед вставкой должно быть допустимым красно-черным деревом. Чтобы решить этот случай, нам нужно проверить, красный или черный дядя К. U.

***Случай 3.1: P красный, U тоже красный.***

В этом случае мы меняем цвет узлов P, U и G. Это означает, что P становится черным, U становится черным, а G становится красным. Это показано на рисунке 5.
![Снимок экрана 2024-02-13 в 11.38.30.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2011.38.30.png)
В этом случае нам следует быть осторожными, когда G является корнем T. В этом случае мы не перекрашиваем G, поскольку это нарушает свойство 2.

***Случай 3.2: P — красный, а U — черный (или NULL).***

Это сложнее, чем случай 3.1. Если дядя-узел U черный, нам нужны одиночные или двойные вращения дерева в зависимости от того, является ли K левым или правым дочерним элементом P.

***Случай 3.2.1: P — правый дочерний элемент G, а K — правый дочерний элемент P.***

Сначала мы выполняем вращение G влево, что делает G новым родственным S для K. Затем мы меняем цвет S на красный, а P на черный. Рисунок 6 иллюстрирует это.
![Снимок экрана 2024-02-13 в 11.41.29.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2011.41.29.png)
***Случай 3.2.2: P — правый дочерний элемент G, а K — левый дочерний элемент P.***

В этом случае мы сначала делаем поворот вправо в точке P. Это сводит его к случаю 3.2.1. Далее мы используем правила, приведенные в случае 3.2.1, чтобы исправить дерево. Это показано на рисунке 7.
![Снимок экрана 2024-02-13 в 11.43.10.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2011.43.10.png)
***Случай 3.2.3: P — левый дочерний элемент G, а K — левый дочерний элемент P.***

Это зеркало случая 3.2.1. Поэтому решение симметрично решению случая 3.2.1.

***Случай 3.2.4: P — левый дочерний элемент G, а K — правый дочерний элемент P.***

Это зеркало случая 3.2.2. Следовательно, решение симметрично решению случая 3.2.2.
****
Основная функция для вставки вершины:
```c++
void RBTree::insert(int key) {
        NodePtr node = new Node;
        node->parent = nullptr;
        node->data = key;
        node->left = TNULL;
        node->right = TNULL;
        node->color = 1;

        NodePtr y = nullptr;
        NodePtr x = this->root;

        while (x != TNULL) {
            y = x;
            if (node->data < x->data) {
                x = x->left;
            }
            else {
                x = x->right;
            }
        }

        //y - родитель x
        node->parent = y;
        if (y == nullptr) {
            root = node;
        }
        else if (node->data < y->data) {
            y->left = node;
        }
        else {
            y->right = node;
        }

        //Если новая вершина - корень, то просто завершаем
        if (node->parent == nullptr) {
            node->color = 0;
            return;
        }

        //Если дед пустой, то просто завершаем
        if (node->parent->parent == nullptr) {
            return;
        }

        //Балансировка
        fixInsert(node);
    }

```
На основе этого алгоритма мы получаем такую функцию для балансировки дерева после вставки:
```c++
void RBTree::fixInsert(NodePtr k) {
NodePtr u;
while (k->parent->color == 1) {
if (k->parent == k->parent->parent->right) {
//Для правой стороны
u = k->parent->parent->left; 
if (u->color == 1) {
// 3.1
u->color = 0;
k->parent->color = 0;
k->parent->parent->color = 1;
k = k->parent->parent;
}
else {
if (k == k->parent->left) {
// 3.2.2
k = k->parent;
rightRotate(k);
}
// 3.2.1
k->parent->color = 0;
k->parent->parent->color = 1;
leftRotate(k->parent->parent);
}
}
else {
//для левой стороны
u = k->parent->parent->right;

                if (u->color == 1) {
                    // 3.1
                    u->color = 0;
                    k->parent->color = 0;
                    k->parent->parent->color = 1;
                    k = k->parent->parent;
                }
                else {
                    if (k == k->parent->right) {
                        // 3.2.2
                        k = k->parent;
                        leftRotate(k);
                    }
                    // 3.2.1
                    k->parent->color = 0;
                    k->parent->parent->color = 1;
                    rightRotate(k->parent->parent);
                }
            }
            if (k == root) {
                break;
            }
        }
        root->color = 0;
    }
```
### Удаление вершины и балансировка дерева после:

Операция удаления сложнее операции вставки. Чтобы удалить узел x из красно-черного дерева, сначала мы следуем обычному процессу удаления BST, который гарантирует, что x является либо листовым узлом, либо имеет единственного дочернего узла. Пусть S и P — родственные и родительские узлы x. Существует несколько случаев операций удаления. Они объяснены ниже.

***Случай 1: x — красный узел***

В данном случае мы просто удаляем x, поскольку удаление красного узла не нарушает никаких свойств.

***Случай 2: у x есть красный ребенок***

Мы заменяем x его красным дочерним элементом и меняем цвет дочернего элемента на красный. Таким образом мы сохраняем свойство 5.

***Случай 3: x — черный узел***

Удаление черного узла нарушает свойство 5. Чтобы сохранить свойство 5, мы добавляем к удаленному узлу дополнительный черный узел и называем его «двойным черным» узлом. Теперь нам нужно преобразовать этот двойной черный узел в один черный узел. Для этого рассмотрим следующие 8 случаев (мы обсуждаем только четыре случая, остальные являются лишь зеркальным отражением этих четырех случаев).

***Случай 3.1: брат x S — красный***

В этом случае мы меняем цвета S и x.parent, а затем выполняем поворот влево для x.parent. Это сводит случай 3.1 к случаю 3.2, 3.3 или 3.4.
![Снимок экрана 2024-02-13 в 14.18.38.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2014.18.38.png)
***Случай 3.2: брат x S — черный, и оба ребенка S — черные.***

Цвет родителя x может быть красным или черным. Меняем цвет S на красный. Если цвет родителя x красный, мы меняем его цвет на черный, и это становится терминальным случаем. В противном случае мы делаем родительским элементом x новый x и повторяем процесс, начиная со случая 3.1. Это показано на рисунке 9.
![Снимок экрана 2024-02-13 в 14.21.38.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2014.21.38.png)
***Случай 3.3: брат x S — черный, левый дочерний элемент S — красный, а правый дочерний элемент S — черный.***

Мы можем переключить цвета S и его левого дочернего элемента S.left, а затем выполнить поворот вправо w, не нарушая ни одного из красно-черных свойств. Это преобразует дерево в случай 3.4. Рисунок 10 иллюстрирует это.
![Снимок экрана 2024-02-13 в 14.23.22.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2014.23.22.png)

***Случай 3.4: брат x S — черный, а правый дочерний элемент S — красный.***

Это смертельный случай. Мы меняем цвет правого дочернего элемента S на черный, родительского узла x на черный и выполняем поворот родительского узла x влево. Таким образом мы удалим лишний черный узел на x. Это показано на рисунке 11. 
![Снимок экрана 2024-02-13 в 14.25.22.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2014.25.22.png)
*****
основная функция, для удаления:
```c++
void RBTree::deleteNode(int data) {
        deleteNodeHelper(this->root, data);
    }
```
дополнительная функция, для удаления вершины:

```c++
void RBTree::deleteNodeHelper(NodePtr node, int key) {
        NodePtr z = TNULL;
        NodePtr x, y;
        while (node != TNULL) {
            if (node->data == key) {
                z = node;
            }

            if (node->data <= key) {
                node = node->right;
            }
            else {
                node = node->left;
            }
        }

        if (z == TNULL) {
            cout << "Couldn't find key in the tree" << endl;
            return;
        }

        y = z;
        int y_original_color = y->color;
        if (z->left == TNULL) { //Этот блок кода определяет, какой тип потомков есть у узла z.
            // Если у узла нет левого потомка, то x присваивается правый потомок z. Если у узла нет правого потомка, то x присваивается левый потомок z
            x = z->right;
            rbTransplant(z, z->right);
        }
        else if (z->right == TNULL) {
            x = z->left;
            rbTransplant(z, z->left);
        }
        else {
            y = minimum(z->right);// В этой строке переменной y присваивается минимальный узел из правого поддерева узла z.
            // Это делается для того, чтобы найти наименьший узел, который будет являться следующим после узла z в порядке возрастания ключей.
            y_original_color = y->color;
            x = y->right;
            if (y->parent == z) { //В этой части кода мы работаем с поддеревом, которое будет заменять удаляемый узел z.
                // Если у узла y нет левого потомка, то мы просто присваиваем правого потомка узла y переменной x.
                //Если у узла y есть левый потомок, то мы используем функцию rbTransplant для замены узла y его правым потомком.
                // Затем правый потомок узла y становится правым потомком узла z.
                x->parent = y;
            }
            else {
                rbTransplant(y, y->right);
                y->right = z->right;
                y->right->parent = y;
            }

            rbTransplant(z, y); //В этой части кода происходит замена узла z узлом y. Мы используем функцию rbTransplant для переноса
            // узла y в позицию узла z.Затем левый потомок узла z становится левым потомком узла y. При этом обновляются ссылки на родителей.
            //Цвет узла y устанавливается равным цвету узла z. Это важно для сохранения инвариантов красно-черного дерева после удаления узла
            y->left = z->left;
            y->left->parent = y;
            y->color = z->color;
        }
        delete z;
        if (y_original_color == 0) {
            fixDelete(x);
        }
    }
```
    
На основе этого алгоритма мы получаем такую функцию для балансировки дерева после удаления:

```c++
        void RBTree::fixDelete(NodePtr x) {
        NodePtr s; 
            while (x != root && x->color == 0) {
            //При левой части
            if (x == x->parent->left) {
            s = x->parent->right;
            if (s->color == 1) { 
            //  3.1
            s->color = 0;
            x->parent->color = 1;
leftRotate(x->parent);
s = x->parent->right;
}

if (s->left->color == 0 && s->right->color == 0) { 
// 3.2
s->color = 1;
x = x->parent;
}
else {
if (s->right->color == 0) { 
//  3.3
s->left->color = 0;
s->color = 1;
rightRotate(s); 
s = x->parent->right;
}

//  3.4
s->color = x->parent->color; 
x->parent->color = 0;
s->right->color = 0;
leftRotate(x->parent);
x = root;
}
}
else {
//При правой части
s = x->parent->left;
if (s->color == 1) {
//  3.1
s->color = 0;
x->parent->color = 1;
rightRotate(x->parent);
s = x->parent->left;
}

if (s->right->color == 0 && s->right->color == 0) {
//  3.2
s->color = 1;
x = x->parent;
}
else {
if (s->left->color == 0) {
//  3.3
s->right->color = 0;
s->color = 1;
leftRotate(s);
s = x->parent->left;
}

//  3.4
s->color = x->parent->color;
x->parent->color = 0;
s->left->color = 0;
rightRotate(x->parent);
x = root;
}
}
}
x->color = 0;
}
```
Так же используются дополнительные функции, например, *поиск нужной вершины по ключу*, *оформление дерева*,*правый\левый повороты (для балансировки)*. Эти функции можно найти в прикрепленных файлах

## Пример выполнения программы

Для начала убедимся, что программа работатет правильно, а именно, проверим самую сложную часть - балансировку при ДОБАВЛЕНИИ и УДАЛЕНИИ вершины

![Снимок экрана 2024-02-13 в 21.26.29.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2021.26.29.png)

Мы видим, что при добавлении узлов балансировка происходит правильно и дерево удовлетворяет всем условиям красно-черного

![Снимок экрана 2024-02-13 в 21.27.33.png](..%2F..%2F..%2F..%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-02-13%20%D0%B2%2021.27.33.png)

На этом скриншоте мы видим, что при удалении узла (№25) дерево сбалансировалось и сделало это правильно, ура !!!
### Тесты остальные пройдены успешно) 