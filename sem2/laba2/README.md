# Лабораторная работа по дисциплине ПиОИвИС №2, второй семестр

## Цель работы

Исследовать свойства структуры данных “множество” и разработать библиотеку для выполнения операции над множеством

## Индивидуальное задание №15
Реализовать программу, формирующую множество равное симметрической разности произвольного количества исходных множеств (без учёта кратных вхождений элементов).
## Ключевые понятия

***Множество*** — любая определенная совокупность объектов.

***Симметрическая разность*** — Множество C называется симметрической разностью множеств A и B, если C состоит из тех элементов и только тех элементов универсального множества U, которые принадлежат множеству A и не принадлежат множеству B или принадлежат множеству B и не принадлежат множеству A.

---

## Выполнение задания

Данная работа описывает взаимодействие с множествами в большинстве своём в виду работы со строками, поэтому порядок действий следующий: считываем файл с множествами в вектор строк (функция `readSets`), проверяем баланс скобок (просто лишняя проверка на входные данные, функция `bracketsBalance`), разбираем каждую строку на элементы вектора, которые в свою очередь являются элементами множества (функция `parseString`), убираем кратные вхождения (в том числе и в подмножествах, функции `removeMultiOccurence` и `removeDuplicatesRecursive`), выполняем симметрическую разность посредством объединением двух разностей обоих множеств (`set_difference` и `set_union`).

---
В функции `parseString` происходит посимвольное считывание строки и её "разбивание" на элементы. Переменная `depth` следит за глубиной подмножества (0 - мы находимся на верхнем уровне), поэтому элемент не попадет в вектор до тех пор, пока не выйдет из подмножества.
```cpp
vector<string> parseString(const string &str)
{
    vector<string> result;
    if(str.empty()) return result;
    string set = str.substr(1, str.length() - 2);
    stringstream ss(set);
    string elem;
    char c;
    int depth = 0;

    while (ss.get(c))
    {
        if (c == ',' && depth == 0)
        {
            if (!elem.empty())
            {   
                result.push_back(elem);
                elem.clear();
            }
        }
        else
        {
            if (c == '<' || c == '{')
            {
                depth++;
            }
            else if (c == '>' || c == '}')
            {
                depth--;
            }
            elem += c;
        }
    }
    if (!elem.empty())
    {
        result.push_back(elem);
    }
    return result;
}
```

---

Функция `stringsAreEqual` предназначена для проверки эквивалентности множеств в виде `{1,2}` и `{2,1}` (запись разная, но множества одинаковые). Сначала происходит считывание строк в вектор элементов, а дальше преобразование в `set` строк (поскольку контейнер `set` заведомо не учитывает кратные вхождения элементов).

```cpp
bool stringsAreEqual(const string &str1, const string &str2) {
    if (str1.front() == '{' && str2.front() == '{') {
        vector<string> vec1 = parseString(str1);
        vector<string> vec2 = parseString(str2);
        set<string> set1(vec1.begin(), vec1.end());
        set<string> set2(vec2.begin(), vec2.end());
        return set1 == set2;
    }
    return str1 == str2;
}
```

---

Удаление кратных вхождений в первую очередь происходит на верхнем уровне множества, а далее рекурсивно в подмножествах. Для этого функция `removeMultiOccurence` будет рекурсивно вызываться до тех пор, пока по бокам строки будут находиться фигурные или угловые скобки.
```cpp
void removeDuplicatesRecursive(vector<string> &set) {
    removeMultiOccurence(set);
    for (string &elem : set) {
        if ((elem.front() == '{' && elem.back() == '}') || (elem.front() == '<' && elem.back() == '>')) {
            vector<string> subset = parseString(elem);
            removeDuplicatesRecursive(subset);
            string newElem(1, elem.front());
            for (size_t i = 0; i < subset.size(); ++i) {
                newElem += subset[i];
                if (i != subset.size() - 1) {
                    newElem += ",";
                }
            }
            newElem += elem.back();
            elem = newElem;
        }
    }  
}
```

---

## Тестирование
Симметрическая разность основана на объединении разностей двух множеств

Входные данные:
```
{o,{},A}
{o,<1,2>,A2,c3,B,b3_A,{},{o,{},A}}
{o,A2,b3,A,<1,2>,{}}
```

Выходные данные:
```
Результат симметрической разности всех множеств: {c3, B, b3_A, {o,{},A}, o, b3, {}}
```


Остальные тестовые программы расположены в директории `/tests`.

---

## Вывод
Была реализована библиотека для нахождения симметрической разности множеств.

---

## Источники
1. https://www.youtube.com/watch?v=dQw4w9WgXcQ
2. Благодарность Романчуку Ивану за [функцию `bracketsBalance`](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%BE%D0%BC%D0%B0%D0%BD%D1%87%D1%83%D0%BA_%D0%98/sem2/lab2/intersection.cpp#L5-L23
)
