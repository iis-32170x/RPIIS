
# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами

### Задание
5.18(Максимальный путь между заданными вершинами)

Реализовать на C++ код, который может Найти максимальный путь между заданными вершинами.

Граф представляется в виде списка смежности(списка инцидентности).

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф (кратко неорграф)` —  Тип графа, в котором ребра не имеют заданного направления, присвоенного им.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

`Поиск в глубину (Depth-first search, DFS)` — один из методов обхода графа.


## Алгоритм решения

1. Создать структуру `Incident`, представляющую собой ребро графа с указанием вершины и веса.

2. Создать функцию `findMaxPath`, которая принимает граф, начальную вершину и конечную вершину в качестве аргументов и возвращает максимальную протяженность пути между этими вершинами.

3. Внутри функции `findMaxPath`:

   a. Получить количество вершин в графе и инициализировать векторы `distance` и `visited` размером `vertices`. Вектор `distance` будет содержать текущие расстояния от начальной вершины до остальных вершин, а вектор `visited` будет отслеживать посещенные вершины.

   b. Установить начальное расстояние от начальной вершины равным 0.

   c. Начать цикл, выполняющийся `vertices - 1` раз:

      i. Найти вершину с максимальным расстоянием (`maxDistanceVertex`), которая еще не посещена.

      ii. Если расстояние до `maxDistanceVertex` равно `numeric_limits<int>::min()`, прервать цикл.

      iii. Пометить `maxDistanceVertex` как посещенную.

      iv. Для каждого смежного ребра `incident` исходящего из `maxDistanceVertex`:

      v. Получить вершину `u` и вес `weight` ребра.

      vi.Если вершина `u` еще не посещена и сумма расстояния от `maxDistanceVertex` до `u` через текущее ребро больше, чем текущее расстояние от начальной вершины до `u`, обновить расстояние до `u`.

   d. Вернуть значение `distance[endVertex]` в качестве максимальной протяженности пути.

4. Внутри функции `main`:

   a. Запросить у пользователя количество вершин (`vertices`) и количество ребер (`edges`).

   b. Создать вектор `graph` размером `vertices`, представляющий собой граф.

   c. В цикле получить от пользователя начальную вершину, конечную вершину и вес ребра `i+1`. Проверить, что введенные вершины находятся в допустимом диапазоне, и добавить ребро в граф.

   d. Запросить у пользователя начальную и конечную вершины пути.

   e. Вызвать функцию `findMaxPath` с графом, начальной вершиной и конечной вершиной, и сохранить результат в переменную `maxPathLength`.

   f. Вывести результат на экран: если `maxPathLength` равно `numeric_limits<int>::min()`, вывести сообщение, что путь не найден, иначе вывести максимальную протяженность пути.

5. Вернуть 0 из функции `main`, указывая успешное завершение программы.



## Реализация на C++


Код, выполняющий наш алгоритм:

```c++
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

struct Incident {
    int vertex;
    int weight;
};

int findMaxPath(const vector<vector<Incident>>& graph, int startVertex, int endVertex) {
    int vertices = graph.size();
    vector<int> distance(vertices, numeric_limits<int>::min());
    vector<bool> visited(vertices, false);

    distance[startVertex] = 0;

    for (int i = 0; i < vertices - 1; ++i) {
        int maxDistanceVertex = -1;

        for (int v = 0; v < vertices; ++v) {
            if (!visited[v] && (maxDistanceVertex == -1 || distance[v] > distance[maxDistanceVertex])) {
                maxDistanceVertex = v;
            }
        }

        if (distance[maxDistanceVertex] == numeric_limits<int>::min()) {
            break;
        }

        visited[maxDistanceVertex] = true;

        for (const auto& incident : graph[maxDistanceVertex]) {
            int u = incident.vertex;
            int weight = incident.weight;

            if (!visited[u] && distance[maxDistanceVertex] + weight > distance[u]) {
                distance[u] = distance[maxDistanceVertex] + weight;
            }
        }
    }

    return distance[endVertex];
}

int main() {
    int vertices, edges;
    cout << "Введите количество вершин: ";
    cin >> vertices;
    cout << "Введите количество ребер: ";
    cin >> edges;

    vector<vector<Incident>> graph(vertices);

    for (int i = 0; i < edges; ++i) {
        int from, to, weight;
        cout << "Введите начальную вершину, конечную вершину и вес ребра " << i + 1 << ": ";
        cin >> from >> to >> weight;

        if (from >= 0 && from < vertices && to >= 0 && to < vertices) {
            graph[from].push_back({to, weight});
        } else {
            cout << "Ошибка: некорректные вершины!" << endl;
            return 1;
        }
    }

    int startVertex, endVertex;
    cout << "Введите начальную вершину пути: ";
    cin >> startVertex;
    cout << "Введите конечную вершину пути: ";
    cin >> endVertex;

    int maxPathLength = findMaxPath(graph, startVertex, endVertex);

    if (maxPathLength == numeric_limits<int>::min()) {
        cout << "Между заданными вершинами нет пути." << endl;
    } else {
        cout << "Максимальная протяженность пути: " << maxPathLength << endl;
    }

    return 0;
}
```

## Разбор кода:

1. Объявление необходимых заголовочных файлов:
```cpp
#include <iostream>
#include <vector>
#include <limits>
```

2. Использование пространства имен `std`:
```cpp
using namespace std;
```

3. Определение структуры `Incident`, представляющей ребро графа с указанием вершины и веса:
```cpp
struct Incident {
    int vertex;
    int weight;
};
```

4. Определение функции `findMaxPath`, которая принимает граф, начальную вершину и конечную вершину в качестве аргументов и возвращает максимальную протяженность пути между этими вершинами:
```cpp
int findMaxPath(const vector<vector<Incident>>& graph, int startVertex, int endVertex) {
    // ...
}
```

5. Определение функции `main`:
```cpp
int main() {
    // ...
}
```

6. Объявление переменных `vertices` и `edges`:
```cpp
int vertices, edges;
```

7. Вывод сообщения для пользователя с запросом ввода количества вершин:
```cpp
cout << "Введите количество вершин: ";
```

8. Ввод значения количества вершин с клавиатуры и сохранение в переменную `vertices`:
```cpp
cin >> vertices;
```

9. Вывод сообщения для пользователя с запросом ввода количества ребер:
```cpp
cout << "Введите количество ребер: ";
```

10. Ввод значения количества ребер с клавиатуры и сохранение в переменную `edges`:
```cpp
cin >> edges;
```

11. Создание вектора `graph` размером `vertices`, представляющего собой граф:
```cpp
vector<vector<Incident>> graph(vertices);
```

12. Цикл для ввода данных о ребрах графа:
```cpp
for (int i = 0; i < edges; ++i) {
    // ...
}
```

13. Вывод сообщения для пользователя с запросом ввода данных о начальной вершине, конечной вершине и весе ребра:
```cpp
cout << "Введите начальную вершину, конечную вершину и вес ребра " << i + 1 << ": ";
```

14. Ввод значений начальной вершины, конечной вершины и веса ребра с клавиатуры и сохранение в переменные `from`, `to` и `weight` соответственно:
```cpp
cin >> from >> to >> weight;
```

15. Проверка корректности введенных вершин и добавление ребра в граф:
```cpp
if (from >= 0 && from < vertices && to >= 0 && to < vertices) {
    graph[from].push_back({to, weight});
} else {
    cout << "Ошибка: некорректные вершины!" << endl;
    return 1;
}
```

16. Объявление переменных `startVertex` и `endVertex`:
```cpp
int startVertex, endVertex;
```

17. Вывод сообщения для пользователя с запросом ввода начальной вершины пути:
```cpp
cout << "Введите начальную вершину пути: ";
```

18. Ввод значения начальной вершины пути с клавиатуры и сохранение в переменную `startVertex`:
```cpp
cin >> startVertex;
```

19. Вывод сообщения для пользователя с запросом ввода конечной вершины пути:
```cpp
cout << "Введите конечную вершину пути: ";
```

20. Ввод значения конечной вершины пути с клавиатуры и сохранение в переменную `endVertex`:
```cpp
cin >> endVertex;
```

21. Вызов функции `findMaxPath` с графом, начальной вершиной и конечной вершиной, и сохранение результата в переменную `maxPathLength`:
```cpp
int maxPathLength = findMaxPath(graph, startVertex, endVertex);
```

22. Вывод результата на экран:
```cpp
if (maxPathLength == numeric_limits<int>::min()) {
    cout << "Путь не найден!" << endl;
} else {
    cout << "Максимальная протяженность пути: " << maxPathLength << endl;
}
```

23. Возврат значения 0 из функции `main`, указывающий успешное завершение программы:
```cpp
return 0;
```
## Тестирование
Все тесты и наглядное изображение графов можетете посмотреть  [здесь](https://github.com/iis-32170x/RPIIS/tree/Батук_Д/RR/tests)

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами, очерядими и файлами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.
